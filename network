----------------------------------------------------------------// UDP 채팅 프로그램

#include "..\..\Common.h"
#include <iostream>
#include <limits>
#include <vector>
#include "헤더.h"
using namespace std;

#define SERVERPORT 9000
#define BUFSIZE    512

DWORD WINAPI RecvThread(LPVOID arg) { // 데이터를 수신만 할 스레드 생성
	SOCKET sock = (SOCKET)arg;
	char buf[BUFSIZE + 1];

	while (1) {
		int retval = recvfrom(sock, buf, BUFSIZE, 0, NULL, NULL);

		if (retval == SOCKET_ERROR)
		{
			printf("recvfrom() 오류\n");
			break;
		}

		buf[retval] = '\0';
		printf("[받은 내용] %s\n", buf);
	}
	return 0;
}


int main(int argc, char* argv[])
{
	if (argc < 2) {
		cout << "인자가 부족합니다" << endl;
		return 1;
	}

	int port = atoi(argv[1]);
	int port2 = atoi(argv[2]);

	int retval;

	cout << "이름을 입력하세요" << endl;
	string name;
	cin >> name;
	cin.ignore(100, '\n');

	int i = 0;
	int size = sizeof(Members) / sizeof(Members[0]);

	while (i < size) {
		if (name != Members[i].name) {
			i++;
		}
		else {
			break;
		}
	}

	// 윈속 초기화
	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
		return 1;

	// 소켓 생성
	SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);
	if (sock == INVALID_SOCKET) err_quit("socket()");

	// 내 서버의 정보를 저장할 구조체
	struct sockaddr_in myaddr;
	memset(&myaddr, 0, sizeof(myaddr));
	myaddr.sin_family = AF_INET;
	myaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	myaddr.sin_port = htons(port);

	retval = bind(sock, (struct sockaddr*)&myaddr, sizeof(myaddr)); 
	if (retval == SOCKET_ERROR) err_quit("bind()");

	// 상대쪽 서버의 정보를 담을 구조체
	struct sockaddr_in serveraddr;
	memset(&serveraddr, 0, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	inet_pton(AF_INET, Members[i].IPAddr.c_str(), &serveraddr.sin_addr);
	serveraddr.sin_port = htons(port2);

	int addrlen;
	char buf[BUFSIZE + 1];
	int len;

	HANDLE Thread = CreateThread(NULL, 0, RecvThread, (LPVOID)sock, 0, NULL); // 스레드 생성

	if (!Thread) {
		printf("스레드 생성 실패\n");
	}

	// 서버와 데이터 통신
	printf("\n[보낼 데이터]\n");
	while (1) {
		// 데이터 입력
		if (fgets(buf, BUFSIZE + 1, stdin) == NULL)
			break;

		// '\n' 문자 제거
		len = (int)strlen(buf);
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		if (strlen(buf) == 0)
			break;

		// 데이터 보내기
		retval = sendto(sock, buf, (int)strlen(buf), 0,
			(struct sockaddr*)&serveraddr, sizeof(serveraddr));
		if (retval == SOCKET_ERROR) {
			err_display("sendto()");
			break;
		}
		printf("[UDP 클라이언트] %d바이트를 보냈습니다.\n", retval);

	}

	// 소켓 닫기
	closesocket(sock);

	// 윈속 종료
	WSACleanup();
	return 0;
}


----------------------------------------------------------------//UDP멀티 채팅

#include <iostream>
#include <string>
#include <vector>
#include <cstring>
#include <limits>
#include <cstdlib>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <conio.h>
using namespace std;


#define BUF_SIZE 1024

struct Peer {
    std::string name;
    std::string ipStr;
    int port;
    sockaddr_in addr;
};

void printPrompt(const std::string& targetName) {
    std::cout << "[송신:" << targetName << "] > ";
    std::cout.flush();
}

int main() {
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        std::cerr << "WSAStartup 실패\n";
        return 1;
    }
    int sockfd;
    sockaddr_in local_addr{};

    int local_port = 0;
    int peerCount = 0;
    std::vector<Peer> peers;

    // ===============================
    // 1. 초기 설정 입력
    // ===============================
    std::cout << "[설정] 내(로컬) 포트 번호를 입력하세요: ";
    std::cin >> local_port;

    std::cout << "[설정] 통신할 사용자(피어)의 수를 입력하세요: ";
    std::cin >> peerCount;

    if (local_port <= 0 || local_port > 65535) {
        std::cerr << "로컬 포트 번호는 1~65535 사이여야 합니다.\n";
        return 1;
    }
    if (peerCount <= 0) {
        std::cerr << "최소 1명 이상의 피어가 필요합니다.\n";
        return 1;
    }

    // 남아 있는 개행 제거 후 getline 사용
    std::cin.ignore(100, '\n');

    peers.reserve(peerCount);
    for (int i = 0; i < peerCount; ++i) {
        Peer p{};
        std::string portStr;

        std::cout << "\n[피어 설정] #" << (i + 1) << " 이름: ";
        std::getline(std::cin, p.name);
        if (p.name.empty()) {
            p.name = "Peer" + std::to_string(i + 1);
        }

        std::cout << "[피어 설정] #" << (i + 1) << " IP 주소: ";
        std::getline(std::cin, p.ipStr);

        std::cout << "[피어 설정] #" << (i + 1) << " 포트 번호: ";
        std::getline(std::cin, portStr);
        p.port = std::stoi(portStr);

        if (p.port <= 0 || p.port > 65535) {
            std::cerr << "포트 번호는 1~65535 사이여야 합니다.\n";
            return 1;
        }

        // sockaddr_in 채우기
        std::memset(&p.addr, 0, sizeof(p.addr));
        p.addr.sin_family = AF_INET;
        p.addr.sin_port = htons(static_cast<uint16_t>(p.port));
        if (::inet_pton(AF_INET, p.ipStr.c_str(), &p.addr.sin_addr) <= 0) {
            std::cerr << "잘못된 IP 주소: " << p.ipStr << "\n";
            return 1;
        }

        peers.push_back(p);
    }

    // 현재 기본 송신 대상 인덱스 (0번째로 시작)
    int currentPeerIdx = 0;
    std::string currentTargetName = peers[currentPeerIdx].name;

    // ===============================
    // 2. UDP 소켓 생성 및 바인드
    // ===============================
    sockfd = ::socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
        return 1;
    }

    std::memset(&local_addr, 0, sizeof(local_addr));
    local_addr.sin_family = AF_INET;
    local_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    local_addr.sin_port = htons(static_cast<uint16_t>(local_port));

    if (::bind(sockfd, reinterpret_cast<sockaddr*>(&local_addr),
        sizeof(local_addr)) < 0) {
        ::closesocket(sockfd);
        return 1;
    }

    std::cout << "\n=== UDP 멀티-유저 채팅 시작 ===\n";
    std::cout << "로컬 포트: " << local_port << "\n";
    std::cout << "등록된 피어 목록:\n";
    for (size_t i = 0; i < peers.size(); ++i) {
        std::cout << "  " << (i + 1) << ") " << peers[i].name
            << " - " << peers[i].ipStr << ":" << peers[i].port << "\n";
    }
    std::cout << "\n명령어:\n";
    std::cout << "  /list        : 피어 목록 보기\n";
    std::cout << "  /use N       : N번째 피어를 현재 송신 대상으로 선택 (1 기반)\n";
    std::cout << "  /all 메시지  : 모든 피어에게 브로드캐스트\n";
    std::cout << "  /quit        : 프로그램 종료\n\n";

    printPrompt(currentTargetName);

    bool running = true;
    string inputBuffer;  // 한 줄 입력 버퍼
    cout << "> ";
    cout.flush();

    // ===============================
    // 3. select 루프
    // ===============================
    while (running) {
        fd_set readfds;
        FD_ZERO(&readfds);
        FD_SET(sockfd, &readfds);

        TIMEVAL tv;
        tv.tv_sec = 0;
        tv.tv_usec = 100000;

        int ret = ::select(0, &readfds, nullptr, nullptr, &tv);
        if (ret < 0) {
            perror("select() 실패");
            break;
        }

        // ---------------------------
        // 3-1. 키보드 입력 처리
        // ---------------------------
        while (_kbhit()) {
            int ch = _getch();   // 에코 없는 입력

            std::string line;
            if (!std::getline(std::cin, line)) {
                std::cout << "\n입력 스트림 종료. 프로그램 종료.\n";
                break;
            }

            if (line.empty()) {
                printPrompt(currentTargetName);
                continue;
            }

            // 명령어 처리
            if (line[0] == '/') {
                if (line == "/quit") {
                    std::cout << "종료합니다.\n";
                    break;
                }
                else if (line == "/list") {
                    std::cout << "\n[피어 목록]\n";
                    for (size_t i = 0; i < peers.size(); ++i) {
                        std::cout << "  " << (i + 1) << ") " << peers[i].name
                            << " - " << peers[i].ipStr << ":" << peers[i].port;
                        if (static_cast<int>(i) == currentPeerIdx) {
                            std::cout << "  <-- 현재 선택";
                        }
                        std::cout << "\n";
                    }
                }
                else if (line.rfind("/use", 0) == 0) {
                    // 형식: /use N
                    std::string numStr = line.substr(4);
                    // 앞뒤 공백 제거
                    auto start = numStr.find_first_not_of(" \t");
                    if (start != std::string::npos) {
                        numStr = numStr.substr(start);
                    }
                    if (!numStr.empty()) {
                        int idx = std::atoi(numStr.c_str());
                        if (idx >= 1 && idx <= static_cast<int>(peers.size())) {
                            currentPeerIdx = idx - 1;
                            currentTargetName = peers[currentPeerIdx].name;
                            std::cout << "현재 송신 대상: "
                                << currentTargetName << "\n";
                        }
                        else {
                            std::cout << "잘못된 인덱스입니다. 1 ~ "
                                << peers.size() << " 범위에서 선택하세요.\n";
                        }
                    }
                    else {
                        std::cout << "사용법: /use N (예: /use 2)\n";
                    }
                }
                else if (line.rfind("/all", 0) == 0) {
                    // 형식: /all 메시지...
                    std::string msg = line.substr(4);
                    auto start = msg.find_first_not_of(" \t");
                    if (start != std::string::npos) {
                        msg = msg.substr(start);
                    }
                    else {
                        msg.clear();
                    }

                    if (msg.empty()) {
                        std::cout << "브로드캐스트할 메시지가 비어 있습니다.\n";
                    }
                    else {
                        for (const auto& p : peers) {
                            SOCKET sent = ::sendto(
                                sockfd,
                                msg.c_str(),
                                msg.size(),
                                0,
                                reinterpret_cast<const sockaddr*>(&p.addr),
                                sizeof(p.addr)
                            );
                            if (sent < 0) {
                                perror("sendto() 실패");
                                break;
                            }
                        }
                        std::cout << "모든 피어에게 전송되었습니다.\n";
                    }
                }
                else {
                    std::cout << "알 수 없는 명령어입니다.\n";
                }

                printPrompt(currentTargetName);
                continue;
            }

            // 일반 메시지: 현재 선택된 피어에게 전송
            if (!peers.empty()) {
                const Peer& target = peers[currentPeerIdx];
                SOCKET sent = ::sendto(
                    sockfd,
                    line.c_str(),
                    line.size(),
                    0,
                    reinterpret_cast<const sockaddr*>(&target.addr),
                    sizeof(target.addr)
                );

                if (sent < 0) {
                    perror("sendto() 실패");
                    break;
                }
            }
            else {
                std::cout << "등록된 피어가 없습니다. 메시지를 보낼 수 없습니다.\n";
            }

            printPrompt(currentTargetName);

        }

        // ---------------------------
        // 3-2. 수신 처리
        // ---------------------------
        if (FD_ISSET(sockfd, &readfds)) {
            char recv_buf[BUF_SIZE + 1];
            sockaddr_in from_addr{};
            socklen_t from_len = sizeof(from_addr);

            SOCKET received = ::recvfrom(
                sockfd,
                recv_buf,
                BUF_SIZE,
                0,
                reinterpret_cast<sockaddr*>(&from_addr),
                &from_len
            );

            if (received == SOCKET_ERROR) {
                cerr << "recvfrom() 실패, 오류 코드: " << WSAGetLastError() << endl;
                continue; // break 대신 continue
            }

            recv_buf[received] = '\0';

            char from_ip[INET_ADDRSTRLEN];
            ::inet_ntop(AF_INET, &from_addr.sin_addr, from_ip, sizeof(from_ip));
            int from_port = ntohs(from_addr.sin_port);

            // 수신한 주소가 등록된 피어인지 확인
            std::string fromName = "Unknown";
            for (const auto& p : peers) {
                if (p.addr.sin_addr.s_addr == from_addr.sin_addr.s_addr &&
                    p.addr.sin_port == from_addr.sin_port) {
                    fromName = p.name;
                    break;
                }
            }

            std::cout << "\n[받음 " << fromName << " (" << from_ip << ":" << from_port
                << ")] " << recv_buf << "\n";


        }
    }

    ::closesocket(sockfd);
    WSACleanup();
    return 0;
}
